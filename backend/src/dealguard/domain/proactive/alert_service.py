"""Alert management service.

This service manages the lifecycle of proactive alerts:
- List and filter alerts
- Mark as seen/in-progress/resolved/dismissed
- Snooze alerts
- Aggregate alert statistics
"""

from collections.abc import Sequence
from dataclasses import dataclass
from datetime import UTC, date, datetime, timedelta
from uuid import UUID

from sqlalchemy import case, func, or_, select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from dealguard.infrastructure.database.models.proactive import (
    AlertSeverity,
    AlertSourceType,
    AlertStatus,
    AlertType,
    ProactiveAlert,
)
from dealguard.shared.logging import get_logger

logger = get_logger(__name__)


@dataclass
class AlertStats:
    """Statistics about alerts."""

    total: int
    new: int
    seen: int
    in_progress: int
    resolved: int
    by_severity: dict[str, int]
    by_type: dict[str, int]


@dataclass
class AlertFilter:
    """Filter options for listing alerts."""

    status: list[AlertStatus] | None = None
    severity: list[AlertSeverity] | None = None
    alert_type: list[AlertType] | None = None
    source_type: AlertSourceType | None = None
    contract_id: UUID | None = None
    partner_id: UUID | None = None
    due_before: date | None = None
    include_snoozed: bool = False


class AlertService:
    """Service for managing proactive alerts.

    Alerts are generated by:
    - DeadlineMonitoringService (approaching/overdue deadlines)
    - PartnerRiskService (partner risk changes)
    - ComplianceService (compliance issues)
    - OpportunityService (savings opportunities)
    """

    def __init__(
        self,
        session: AsyncSession,
        *,
        organization_id: UUID,
        user_id: UUID,
    ) -> None:
        self.session = session
        self.organization_id = organization_id
        self.user_id = user_id

    def _get_organization_id(self) -> UUID:
        return self.organization_id

    def _get_user_id(self) -> UUID:
        return self.user_id

    # ─────────────────────────────────────────────────────────────
    #                  ALERT LISTING
    # ─────────────────────────────────────────────────────────────

    async def list_alerts(
        self,
        filter: AlertFilter | None = None,
        offset: int = 0,
        limit: int = 50,
    ) -> Sequence[ProactiveAlert]:
        """List alerts with optional filtering."""
        org_id = self._get_organization_id()
        filter = filter or AlertFilter()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .options(
                selectinload(ProactiveAlert.related_contract),
                selectinload(ProactiveAlert.related_partner),
            )
        )

        # Apply filters
        if filter.status:
            query = query.where(ProactiveAlert.status.in_(filter.status))

        if filter.severity:
            query = query.where(ProactiveAlert.severity.in_(filter.severity))

        if filter.alert_type:
            query = query.where(ProactiveAlert.alert_type.in_(filter.alert_type))

        if filter.source_type:
            query = query.where(ProactiveAlert.source_type == filter.source_type)

        if filter.contract_id:
            query = query.where(ProactiveAlert.related_contract_id == filter.contract_id)

        if filter.partner_id:
            query = query.where(ProactiveAlert.related_partner_id == filter.partner_id)

        if filter.due_before:
            query = query.where(ProactiveAlert.due_date <= filter.due_before)

        # Exclude snoozed unless explicitly requested
        if not filter.include_snoozed:
            now = datetime.now(UTC)
            query = query.where(
                or_(
                    ProactiveAlert.snoozed_until.is_(None),
                    ProactiveAlert.snoozed_until <= now,
                )
            )

        # Order by severity (critical first) then by creation date
        severity_rank = case(
            (ProactiveAlert.severity == AlertSeverity.CRITICAL, 0),
            (ProactiveAlert.severity == AlertSeverity.HIGH, 1),
            (ProactiveAlert.severity == AlertSeverity.MEDIUM, 2),
            (ProactiveAlert.severity == AlertSeverity.LOW, 3),
            (ProactiveAlert.severity == AlertSeverity.INFO, 4),
            else_=5,
        )
        query = query.order_by(
            severity_rank.asc(),
            ProactiveAlert.created_at.desc(),
        )

        query = query.offset(offset).limit(limit)

        result = await self.session.execute(query)
        return result.scalars().all()

    async def count_alerts(self, filter: AlertFilter | None = None) -> int:
        """Count alerts matching a filter (for pagination)."""
        org_id = self._get_organization_id()
        filter = filter or AlertFilter()

        query = (
            select(func.count())
            .select_from(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
        )

        if filter.status:
            query = query.where(ProactiveAlert.status.in_(filter.status))

        if filter.severity:
            query = query.where(ProactiveAlert.severity.in_(filter.severity))

        if filter.alert_type:
            query = query.where(ProactiveAlert.alert_type.in_(filter.alert_type))

        if filter.source_type:
            query = query.where(ProactiveAlert.source_type == filter.source_type)

        if filter.contract_id:
            query = query.where(ProactiveAlert.related_contract_id == filter.contract_id)

        if filter.partner_id:
            query = query.where(ProactiveAlert.related_partner_id == filter.partner_id)

        if filter.due_before:
            query = query.where(ProactiveAlert.due_date <= filter.due_before)

        if not filter.include_snoozed:
            now = datetime.now(UTC)
            query = query.where(
                or_(
                    ProactiveAlert.snoozed_until.is_(None),
                    ProactiveAlert.snoozed_until <= now,
                )
            )

        result = await self.session.execute(query)
        return int(result.scalar_one() or 0)

    async def get_alert(self, alert_id: UUID) -> ProactiveAlert | None:
        """Get a single alert by ID."""
        org_id = self._get_organization_id()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.id == alert_id)
            .where(ProactiveAlert.organization_id == org_id)
            .options(
                selectinload(ProactiveAlert.related_contract),
                selectinload(ProactiveAlert.related_partner),
            )
        )

        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_actionable_alerts(
        self,
        limit: int = 10,
    ) -> Sequence[ProactiveAlert]:
        """Get alerts that need attention (new, seen, in_progress)."""
        return await self.list_alerts(
            filter=AlertFilter(
                status=[AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS],
            ),
            limit=limit,
        )

    async def get_critical_alerts(
        self,
        limit: int = 10,
    ) -> Sequence[ProactiveAlert]:
        """Get critical/high severity alerts."""
        return await self.list_alerts(
            filter=AlertFilter(
                status=[AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS],
                severity=[AlertSeverity.CRITICAL, AlertSeverity.HIGH],
            ),
            limit=limit,
        )

    # ─────────────────────────────────────────────────────────────
    #                  ALERT STATISTICS
    # ─────────────────────────────────────────────────────────────

    async def get_stats(self) -> AlertStats:
        """Get alert statistics for the organization."""
        org_id = self._get_organization_id()
        status_query = (
            select(
                func.count().label("total"),
                func.count().filter(ProactiveAlert.status == AlertStatus.NEW).label("new"),
                func.count().filter(ProactiveAlert.status == AlertStatus.SEEN).label("seen"),
                func.count()
                .filter(ProactiveAlert.status == AlertStatus.IN_PROGRESS)
                .label("in_progress"),
                func.count()
                .filter(ProactiveAlert.status.in_([AlertStatus.RESOLVED, AlertStatus.DISMISSED]))
                .label("resolved"),
            )
            .select_from(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
        )
        status_result = await self.session.execute(status_query)
        status_row = status_result.one()

        severity_query = (
            select(ProactiveAlert.severity, func.count())
            .where(ProactiveAlert.organization_id == org_id)
            .group_by(ProactiveAlert.severity)
        )
        severity_result = await self.session.execute(severity_query)
        by_severity = {severity.value: 0 for severity in AlertSeverity}
        for severity, count in severity_result.all():
            by_severity[severity.value] = int(count)

        type_query = (
            select(ProactiveAlert.alert_type, func.count())
            .where(ProactiveAlert.organization_id == org_id)
            .group_by(ProactiveAlert.alert_type)
        )
        type_result = await self.session.execute(type_query)
        by_type = {alert_type.value: int(count) for alert_type, count in type_result.all()}

        return AlertStats(
            total=int(status_row.total or 0),
            new=int(status_row.new or 0),
            seen=int(status_row.seen or 0),
            in_progress=int(status_row.in_progress or 0),
            resolved=int(status_row.resolved or 0),
            by_severity=by_severity,
            by_type=by_type,
        )

    async def count_new_alerts(self) -> int:
        """Quick count of new alerts (for badge display)."""
        org_id = self._get_organization_id()
        now = datetime.now(UTC)

        query = (
            select(func.count())
            .select_from(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.NEW)
            .where(
                or_(
                    ProactiveAlert.snoozed_until.is_(None),
                    ProactiveAlert.snoozed_until <= now,
                )
            )
        )

        result = await self.session.execute(query)
        return result.scalar() or 0

    # ─────────────────────────────────────────────────────────────
    #                  ALERT ACTIONS
    # ─────────────────────────────────────────────────────────────

    async def mark_seen(self, alert_id: UUID) -> ProactiveAlert | None:
        """Mark alert as seen (user has viewed it)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        if alert.status == AlertStatus.NEW:
            alert.status = AlertStatus.SEEN

        await self.session.flush()

        logger.info(
            "alert_marked_seen",
            alert_id=str(alert_id),
        )

        return alert

    async def mark_in_progress(self, alert_id: UUID) -> ProactiveAlert | None:
        """Mark alert as being worked on."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        alert.status = AlertStatus.IN_PROGRESS

        await self.session.flush()

        logger.info(
            "alert_marked_in_progress",
            alert_id=str(alert_id),
        )

        return alert

    async def resolve(
        self,
        alert_id: UUID,
        action: str,
        notes: str | None = None,
    ) -> ProactiveAlert | None:
        """Resolve an alert (action taken)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        user_id = self._get_user_id()

        alert.status = AlertStatus.RESOLVED
        alert.resolved_at = datetime.now(UTC)
        alert.resolved_by = user_id
        alert.resolution_action = action
        alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alert_resolved",
            alert_id=str(alert_id),
            action=action,
        )

        return alert

    async def dismiss(
        self,
        alert_id: UUID,
        notes: str | None = None,
    ) -> ProactiveAlert | None:
        """Dismiss an alert (not relevant)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        user_id = self._get_user_id()

        alert.status = AlertStatus.DISMISSED
        alert.resolved_at = datetime.now(UTC)
        alert.resolved_by = user_id
        alert.resolution_action = "dismissed"
        alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alert_dismissed",
            alert_id=str(alert_id),
        )

        return alert

    async def snooze(
        self,
        alert_id: UUID,
        until: datetime | None = None,
        days: int | None = None,
    ) -> ProactiveAlert | None:
        """Snooze an alert until a specific time."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        if until:
            snooze_until = until
        elif days:
            snooze_until = datetime.now(UTC) + timedelta(days=days)
        else:
            # Default: snooze for 3 days
            snooze_until = datetime.now(UTC) + timedelta(days=3)

        alert.status = AlertStatus.SNOOZED
        alert.snoozed_until = snooze_until

        await self.session.flush()

        logger.info(
            "alert_snoozed",
            alert_id=str(alert_id),
            until=snooze_until.isoformat(),
        )

        return alert

    async def unsnooze(self, alert_id: UUID) -> ProactiveAlert | None:
        """Unsnooze an alert (bring it back immediately)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        alert.status = AlertStatus.NEW
        alert.snoozed_until = None

        await self.session.flush()

        logger.info(
            "alert_unsnoozed",
            alert_id=str(alert_id),
        )

        return alert

    # ─────────────────────────────────────────────────────────────
    #                  BULK OPERATIONS
    # ─────────────────────────────────────────────────────────────

    async def mark_all_seen(self) -> int:
        """Mark all new alerts as seen."""
        org_id = self._get_organization_id()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.NEW)
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.SEEN

        await self.session.flush()

        logger.info(
            "all_alerts_marked_seen",
            count=len(alerts),
        )

        return len(alerts)

    async def dismiss_all_by_contract(
        self,
        contract_id: UUID,
        notes: str | None = None,
    ) -> int:
        """Dismiss all alerts related to a contract."""
        org_id = self._get_organization_id()
        user_id = self._get_user_id()
        now = datetime.now(UTC)

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.related_contract_id == contract_id)
            .where(
                ProactiveAlert.status.in_(
                    [AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS]
                )
            )
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.DISMISSED
            alert.resolved_at = now
            alert.resolved_by = user_id
            alert.resolution_action = "bulk_dismissed"
            alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alerts_dismissed_for_contract",
            contract_id=str(contract_id),
            count=len(alerts),
        )

        return len(alerts)

    # ─────────────────────────────────────────────────────────────
    #              BACKGROUND WORKER HELPERS
    # ─────────────────────────────────────────────────────────────

    async def wake_snoozed_alerts(self) -> int:
        """Wake up alerts whose snooze period has ended.

        This should be called by the background worker.
        """
        org_id = self._get_organization_id()
        now = datetime.now(UTC)

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.SNOOZED)
            .where(ProactiveAlert.snoozed_until <= now)
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.NEW
            alert.snoozed_until = None

        await self.session.flush()

        if alerts:
            logger.info(
                "snoozed_alerts_awakened",
                count=len(alerts),
            )

        return len(alerts)
