"""Alert management service.

This service manages the lifecycle of proactive alerts:
- List and filter alerts
- Mark as seen/in-progress/resolved/dismissed
- Snooze alerts
- Aggregate alert statistics
"""

from dataclasses import dataclass
from datetime import date, datetime, timezone, timedelta
from typing import Sequence
from uuid import UUID

from sqlalchemy import select, func, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from dealguard.infrastructure.database.models.proactive import (
    ProactiveAlert,
    AlertSourceType,
    AlertType,
    AlertSeverity,
    AlertStatus,
)
from dealguard.shared.logging import get_logger

logger = get_logger(__name__)


@dataclass
class AlertStats:
    """Statistics about alerts."""

    total: int
    new: int
    seen: int
    in_progress: int
    resolved: int
    by_severity: dict[str, int]
    by_type: dict[str, int]


@dataclass
class AlertFilter:
    """Filter options for listing alerts."""

    status: list[AlertStatus] | None = None
    severity: list[AlertSeverity] | None = None
    alert_type: list[AlertType] | None = None
    source_type: AlertSourceType | None = None
    contract_id: UUID | None = None
    partner_id: UUID | None = None
    due_before: date | None = None
    include_snoozed: bool = False


class AlertService:
    """Service for managing proactive alerts.

    Alerts are generated by:
    - DeadlineMonitoringService (approaching/overdue deadlines)
    - PartnerRiskService (partner risk changes)
    - ComplianceService (compliance issues)
    - OpportunityService (savings opportunities)
    """

    def __init__(
        self,
        session: AsyncSession,
        *,
        organization_id: UUID,
        user_id: UUID,
    ) -> None:
        self.session = session
        self.organization_id = organization_id
        self.user_id = user_id

    def _get_organization_id(self) -> UUID:
        return self.organization_id

    def _get_user_id(self) -> UUID:
        return self.user_id

    # ─────────────────────────────────────────────────────────────
    #                  ALERT LISTING
    # ─────────────────────────────────────────────────────────────

    async def list_alerts(
        self,
        filter: AlertFilter | None = None,
        offset: int = 0,
        limit: int = 50,
    ) -> Sequence[ProactiveAlert]:
        """List alerts with optional filtering."""
        org_id = self._get_organization_id()
        filter = filter or AlertFilter()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .options(
                selectinload(ProactiveAlert.related_contract),
                selectinload(ProactiveAlert.related_partner),
            )
        )

        # Apply filters
        if filter.status:
            query = query.where(ProactiveAlert.status.in_(filter.status))

        if filter.severity:
            query = query.where(ProactiveAlert.severity.in_(filter.severity))

        if filter.alert_type:
            query = query.where(ProactiveAlert.alert_type.in_(filter.alert_type))

        if filter.source_type:
            query = query.where(ProactiveAlert.source_type == filter.source_type)

        if filter.contract_id:
            query = query.where(ProactiveAlert.related_contract_id == filter.contract_id)

        if filter.partner_id:
            query = query.where(ProactiveAlert.related_partner_id == filter.partner_id)

        if filter.due_before:
            query = query.where(ProactiveAlert.due_date <= filter.due_before)

        # Exclude snoozed unless explicitly requested
        if not filter.include_snoozed:
            now = datetime.now(timezone.utc)
            query = query.where(
                or_(
                    ProactiveAlert.snoozed_until.is_(None),
                    ProactiveAlert.snoozed_until <= now,
                )
            )

        # Order by severity (critical first) then by creation date
        severity_order = [
            AlertSeverity.CRITICAL,
            AlertSeverity.HIGH,
            AlertSeverity.MEDIUM,
            AlertSeverity.LOW,
            AlertSeverity.INFO,
        ]
        # Use case/when for custom ordering
        query = query.order_by(
            ProactiveAlert.severity.desc(),
            ProactiveAlert.created_at.desc(),
        )

        query = query.offset(offset).limit(limit)

        result = await self.session.execute(query)
        return result.scalars().all()

    async def get_alert(self, alert_id: UUID) -> ProactiveAlert | None:
        """Get a single alert by ID."""
        org_id = self._get_organization_id()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.id == alert_id)
            .where(ProactiveAlert.organization_id == org_id)
            .options(
                selectinload(ProactiveAlert.related_contract),
                selectinload(ProactiveAlert.related_partner),
            )
        )

        result = await self.session.execute(query)
        return result.scalar_one_or_none()

    async def get_actionable_alerts(
        self,
        limit: int = 10,
    ) -> Sequence[ProactiveAlert]:
        """Get alerts that need attention (new, seen, in_progress)."""
        return await self.list_alerts(
            filter=AlertFilter(
                status=[AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS],
            ),
            limit=limit,
        )

    async def get_critical_alerts(
        self,
        limit: int = 10,
    ) -> Sequence[ProactiveAlert]:
        """Get critical/high severity alerts."""
        return await self.list_alerts(
            filter=AlertFilter(
                status=[AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS],
                severity=[AlertSeverity.CRITICAL, AlertSeverity.HIGH],
            ),
            limit=limit,
        )

    # ─────────────────────────────────────────────────────────────
    #                  ALERT STATISTICS
    # ─────────────────────────────────────────────────────────────

    async def get_stats(self) -> AlertStats:
        """Get alert statistics for the organization."""
        org_id = self._get_organization_id()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        # Count by status
        status_counts = {status: 0 for status in AlertStatus}
        for alert in alerts:
            status_counts[alert.status] += 1

        # Count by severity
        severity_counts = {severity.value: 0 for severity in AlertSeverity}
        for alert in alerts:
            severity_counts[alert.severity.value] += 1

        # Count by type
        type_counts: dict[str, int] = {}
        for alert in alerts:
            type_counts[alert.alert_type.value] = type_counts.get(alert.alert_type.value, 0) + 1

        return AlertStats(
            total=len(alerts),
            new=status_counts[AlertStatus.NEW],
            seen=status_counts[AlertStatus.SEEN],
            in_progress=status_counts[AlertStatus.IN_PROGRESS],
            resolved=status_counts[AlertStatus.RESOLVED] + status_counts[AlertStatus.DISMISSED],
            by_severity=severity_counts,
            by_type=type_counts,
        )

    async def count_new_alerts(self) -> int:
        """Quick count of new alerts (for badge display)."""
        org_id = self._get_organization_id()
        now = datetime.now(timezone.utc)

        query = (
            select(func.count())
            .select_from(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.NEW)
            .where(
                or_(
                    ProactiveAlert.snoozed_until.is_(None),
                    ProactiveAlert.snoozed_until <= now,
                )
            )
        )

        result = await self.session.execute(query)
        return result.scalar() or 0

    # ─────────────────────────────────────────────────────────────
    #                  ALERT ACTIONS
    # ─────────────────────────────────────────────────────────────

    async def mark_seen(self, alert_id: UUID) -> ProactiveAlert | None:
        """Mark alert as seen (user has viewed it)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        if alert.status == AlertStatus.NEW:
            alert.status = AlertStatus.SEEN

        await self.session.flush()

        logger.info(
            "alert_marked_seen",
            alert_id=str(alert_id),
        )

        return alert

    async def mark_in_progress(self, alert_id: UUID) -> ProactiveAlert | None:
        """Mark alert as being worked on."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        alert.status = AlertStatus.IN_PROGRESS

        await self.session.flush()

        logger.info(
            "alert_marked_in_progress",
            alert_id=str(alert_id),
        )

        return alert

    async def resolve(
        self,
        alert_id: UUID,
        action: str,
        notes: str | None = None,
    ) -> ProactiveAlert | None:
        """Resolve an alert (action taken)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        user_id = self._get_user_id()

        alert.status = AlertStatus.RESOLVED
        alert.resolved_at = datetime.now(timezone.utc)
        alert.resolved_by = user_id
        alert.resolution_action = action
        alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alert_resolved",
            alert_id=str(alert_id),
            action=action,
        )

        return alert

    async def dismiss(
        self,
        alert_id: UUID,
        notes: str | None = None,
    ) -> ProactiveAlert | None:
        """Dismiss an alert (not relevant)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        user_id = self._get_user_id()

        alert.status = AlertStatus.DISMISSED
        alert.resolved_at = datetime.now(timezone.utc)
        alert.resolved_by = user_id
        alert.resolution_action = "dismissed"
        alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alert_dismissed",
            alert_id=str(alert_id),
        )

        return alert

    async def snooze(
        self,
        alert_id: UUID,
        until: datetime | None = None,
        days: int | None = None,
    ) -> ProactiveAlert | None:
        """Snooze an alert until a specific time."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        if until:
            snooze_until = until
        elif days:
            snooze_until = datetime.now(timezone.utc) + timedelta(days=days)
        else:
            # Default: snooze for 3 days
            snooze_until = datetime.now(timezone.utc) + timedelta(days=3)

        alert.status = AlertStatus.SNOOZED
        alert.snoozed_until = snooze_until

        await self.session.flush()

        logger.info(
            "alert_snoozed",
            alert_id=str(alert_id),
            until=snooze_until.isoformat(),
        )

        return alert

    async def unsnooze(self, alert_id: UUID) -> ProactiveAlert | None:
        """Unsnooze an alert (bring it back immediately)."""
        alert = await self.get_alert(alert_id)
        if not alert:
            return None

        alert.status = AlertStatus.NEW
        alert.snoozed_until = None

        await self.session.flush()

        logger.info(
            "alert_unsnoozed",
            alert_id=str(alert_id),
        )

        return alert

    # ─────────────────────────────────────────────────────────────
    #                  BULK OPERATIONS
    # ─────────────────────────────────────────────────────────────

    async def mark_all_seen(self) -> int:
        """Mark all new alerts as seen."""
        org_id = self._get_organization_id()

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.NEW)
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.SEEN

        await self.session.flush()

        logger.info(
            "all_alerts_marked_seen",
            count=len(alerts),
        )

        return len(alerts)

    async def dismiss_all_by_contract(
        self,
        contract_id: UUID,
        notes: str | None = None,
    ) -> int:
        """Dismiss all alerts related to a contract."""
        org_id = self._get_organization_id()
        user_id = self._get_user_id()
        now = datetime.now(timezone.utc)

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.related_contract_id == contract_id)
            .where(ProactiveAlert.status.in_([
                AlertStatus.NEW, AlertStatus.SEEN, AlertStatus.IN_PROGRESS
            ]))
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.DISMISSED
            alert.resolved_at = now
            alert.resolved_by = user_id
            alert.resolution_action = "bulk_dismissed"
            alert.resolution_notes = notes

        await self.session.flush()

        logger.info(
            "alerts_dismissed_for_contract",
            contract_id=str(contract_id),
            count=len(alerts),
        )

        return len(alerts)

    # ─────────────────────────────────────────────────────────────
    #              BACKGROUND WORKER HELPERS
    # ─────────────────────────────────────────────────────────────

    async def wake_snoozed_alerts(self) -> int:
        """Wake up alerts whose snooze period has ended.

        This should be called by the background worker.
        """
        org_id = self._get_organization_id()
        now = datetime.now(timezone.utc)

        query = (
            select(ProactiveAlert)
            .where(ProactiveAlert.organization_id == org_id)
            .where(ProactiveAlert.status == AlertStatus.SNOOZED)
            .where(ProactiveAlert.snoozed_until <= now)
        )
        result = await self.session.execute(query)
        alerts = result.scalars().all()

        for alert in alerts:
            alert.status = AlertStatus.NEW
            alert.snoozed_until = None

        await self.session.flush()

        if alerts:
            logger.info(
                "snoozed_alerts_awakened",
                count=len(alerts),
            )

        return len(alerts)
